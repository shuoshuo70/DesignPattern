单例模式：
对象定义成private static  private是因为阻止外部直接调用，static是为了保证只有一个实例
构造方法private 这样阻止外部通过new 创建对象
只提供一个public static的方法来获取对象 方法是static是因为不能通过new来创建实例，只能通过类名.静态
方法的方式访问，所以提供的方法一定要是static的才行

1. 饿汉式 SingletonHungry
   在定义对象的时候就创建出一个静态的对象，每次用的时候都取这个对象，好处是可以直接应用于多线程中，
   线程安全，缺点是在未使用的时候就创建了，提前占用了系统资源
2. 懒汉式 SingletonLazy
   在定义对象的时候赋值为null，用的时候判断对象如果是null，则创建对象，否则取用原来的对象。好处是
   用的时候才创建，不浪费资源，但是存在线程安全的问题，比如，两个线程都判断对象为null，那么两个
   线程都去创建了对象，不能保证单例了，作如下改进：
3. 双重锁 SingletonLock
   加锁：synchronized锁定资源，由于对象还没创建，锁不了，所以创建一个Object对象，专门用于加锁
   先判断对象是否存在，如果不存在再加锁，在锁内部再判断对象是否存在，不存在再创建
   双重判断的原因：
       加锁前判断，是为了提高效率，有对象的话就不用加锁了
       加锁内判断，因为线程是排队进入的，可以在排队的时候还没有对象，但是等到它执行的时候对象已经
       生成了
   由于指令重排序，初始化Singleton和对象地址赋值给instance字段的顺序是不确定的，加入volatile字段
   保证初始化的顺序
4. 静态内部类式  SingletonInnerStactic
   与饿汉方式类似，都是通过类加载机制保证了instance的唯一性，可用在并发场景，不一样的是，是在内部
   类中去创建对象，只要应用不使用内部类，JVM就不会加载这个实例，解决了饿汉模式不能延迟加载的问题

实际应用中常采用3,4的方式


应用场景：
1. 任务管理器  因为windows是多进程多线程系统，会有多个操作同时操作一个文件，单例可以避免混乱
2. 垃圾回收站
3. 数据库的连接池， 因为db的连接和关闭很耗时，这样可以提高效率
4. 线程池，方便对线程池中的线程进行控制


单例的优势：
1. 控制资源的使用，通过线程同步来控制并发的访问
2. 资源的共享
3. 控制实例产生的数量，节省资源


